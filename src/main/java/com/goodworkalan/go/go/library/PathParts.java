package com.goodworkalan.go.go.library;

import static com.goodworkalan.go.go.GoException.MALFORMED_URL;

import java.io.File;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.ArrayList;
import java.util.Collection;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;

import com.goodworkalan.go.go.GoException;

/**
 * Static utility methods for converting path part collections into useful
 * collections of files or URLs.
 * 
 * @author Alan Gutierrez
 */
public class PathParts {
    /** This static method container should not be instantiated. */
    PathParts() {
    }

    /**
     * Convert the collection of path parts into an ordered set of files. A file
     * in the array returned are in the same order as the path part that
     * generated it in the given collection.
     * 
     * @param parts
     *            The collection of path parts.
     * @return An order set of the URLs generated by the path parts.
     * @throws UnsupportedOperationException
     *             If any of the path parts are expanding path parts.
     */
    public static Set<File> fileSet(Collection<PathPart> parts) {
        Set<File> set = new LinkedHashSet<File>();
        for (PathPart part : parts) {
            set.add(part.getFile());
        }
        return set;
    }

    /**
     * Convert the collection of path parts into an array of files. A file in
     * the array returned are in the same order as the path part that generated
     * it in the given collection.
     * 
     * @param parts
     *            The collection of path parts.
     * @return An array of files.
     * @throws UnsupportedOperationException
     *             If any of the path parts are expanding path parts.
     */
    public static File[] files(Collection<PathPart> parts) {
        Set<File> files = fileSet(parts);
        return files.toArray(new File[files.size()]);
    }

    /**
     * Convert the collection of path parts into an ordered set of URLs. A URL
     * in the array returned are in the same order as the path part that
     * generated it in the given collection.
     * 
     * @param parts
     *            The collection of path parts.
     * @return An order set of the URLs generated by the path parts.
     * @throws UnsupportedOperationException
     *             If any of the path parts are expanding path parts.
     */
    public static Set<URL> urlSet(Collection<PathPart> parts) {
        Set<URL> set = new LinkedHashSet<URL>();
        for (PathPart part : parts) {
            set.add(part.getURL());
        }
        return set;
    }

    /**
     * Convert the collection of path parts into a list of URLs. A URL in the
     * array returned are in the same order as the path part that generated it
     * in the given collection.
     * 
     * @param parts
     *            The collection of path parts.
     * @return An array of URLs.
     * @throws UnsupportedOperationException
     *             If any of the path parts are expanding path parts.
     */
    public static URL[] urls(Collection<PathPart> parts) {
        Set<URL> urls = urlSet(parts);
        return urls.toArray(new URL[urls.size()]);
    }

    /**
     * Create a class loader from the given collection of path parts using the
     * given parent class loader as a parent.
     * 
     * @param parts
     *            The collection of path parts.
     * @param parent
     *            The parent class loader.
     * @return A class loader that will search for classes in the class path
     *         represented by the path parts.
     * @throws UnsupportedOperationException
     *             If any of the path parts are expanding path parts.
     */
    public static ClassLoader getClassLoader(Collection<PathPart> parts, ClassLoader parent) {
        return new URLClassLoader(urls(parts), parent);
    }

    /**
     * Attempt to parse the given url string and wrap a malformed URL exception
     * in an unchecked exception.
     * <p>
     * As is often the case, there is little you can do if someone specifies a
     * dependency for their program using a malformed URL. The dependency will
     * not be found whether it is present or not. It is an unrecoverable,
     * programming error, a truly exceptional condition.
     * <p>
     * Implementations of <code>PathPart</code> can use this method to convert
     * their URLs so that they to not have to design a test for a condition they
     * have most likely already guarded against.
     * 
     * @param url
     *            The URL to parse.
     * @return The URL.
     */
    public static URL toURL(String url) {
        try {
            return new URL(url);
        } catch (MalformedURLException e) {
            throw new GoException(MALFORMED_URL, url);
        }
    }
    
    // TODO Document.
    public static List<Artifact> artifactsList(Collection<PathPart> parts) {
        List<Artifact> artifacts = new ArrayList<Artifact>();
        for (PathPart part : parts) {
            if (part.getArtifact() != null) {
                artifacts.add(part.getArtifact());
            }
        }
        return artifacts;
    }
}
